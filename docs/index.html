<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Gleam</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/normalize.css@8.0.1/normalize.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Karla&display=swap"
    />
    <link rel="stylesheet" href="/index.css" />
  </head>
  <body>
    <nav class="pagenav content">
      <a href="/">
        <h1 class="pagenav-title">Gleam</h1>
      </a>
      <span class="flex-spacer"></span>

      <a href="https://lpil.uk/#blog">News</a>
      <a href="/book">Documentation</a>
      <iframe
        src="https://github.com/sponsors/lpil/button"
        title="Sponsor Gleam"
        height="35"
        width="116"
        style="border: 0; padding-left: 8px"
      ></iframe>
    </nav>

    <section class="hero">
      <div class="hero-content content">
        <img
          class="hero-logo"
          src="/images/lucy-charcoal-2.svg"
          alt="Lucy the star, Gleam's mascot"
        />
        <h2 class="hero-blerb">
          Gleam is a fast, friendly, and functional language for building safe,
          scalable systems! âœ¨
        </h2>
      </div>
    </section>

    <section class="content">
      <h2>Why Gleam?</h2>

      <h3 data-before-icon="â˜”">Safe</h3>
      <p>
        An expressive type system inspired by the ML family of languages helps
        us find and prevent bugs at compile time, long before it reaches your
        users.
      </p>
      <p>
        For the problems the type system can't solve (such as your server being
        hit by a bolt of lightning) the Erlang/OTP runtime provides well tested
        mechanisms for gracefully handling failure.
      </p>

      <h3 data-before-icon="ðŸ’œ">Friendly</h3>
      <p>
        Hunting down bugs can be stressful so feedback from the compiler should
        be as clear and helpful as possible. We want to spend more time working
        on our application and less time looking for typos or deciphering
        cryptic error messages.
      </p>
      <p>
        As a community we want to be friendly too. People of all backgrounds,
        genders, and experience levels are welcome and must receive equal
        respect.
      </p>

      <h3 data-before-icon="ðŸ§µ">Performant</h3>
      <p>
        The Erlang/OTP runtime is known for its speed and ability to scale,
        enabling organisations such as WhatsApp and Ericsson to reliably handle
        massive amounts of traffic at low latency. Gleam should take full
        advantage of this runtime and be as fast as other BEAM languages such as
        Erlang and Elixir.
      </p>

      <h3 data-before-icon="ðŸ§©">Erlang compatible</h3>
      <p>
        Gleam makes it easy to use code written in other BEAM languages such as
        Erlang, Elixir and LFE, so there's a rich ecosystem of tools and library
        for Gleam users to make use of.
      </p>

      <p>
        Users of other BEAM languages should in return be able to take advantage
        of Gleam, either by transparently making use of libraries written in
        Gleam, or by adding Gleam modules to their existing project with minimal
        fuss.
      </p>

      <h2>Examples</h2>

      <details class="openable-example" open>
        <summary>Hello, world!</summary>

        The classic example program that prints "Hello, world!" to the console.

        <pre><code class="language-rust">import gleam/io

pub fn main() {
  io.println("Hello, world!")
}
</code></pre>
      </details>

      <details class="openable-example">
        <summary>A basic web server</summary>

        This little web server response with the text "Hello, world!" to any
        HTTP request made to it.

        <pre><code class="language-rust">import gleam/http/elli
import gleam/http

pub fn my_service(_req) {
  let body = bit_builder.from_string("Hello, world!")

  http.response(200)
  |&gt; http.set_resp_body(body)
}

pub fn start() {
  elli.start(my_service, on_port: 3000)
}
</code></pre>

        The web server created by this code is fully asynchronous and
        multi-threaded, seamlessly making use of all the cores of your computer
        without tricky locks, callbacks, or promises.
      </details>

      <details class="openable-example">
        <summary>Multi-threaded hello world</summary>

        Thanks to the powerful Erlang virtual machine Gleam programs can spin up
        hundreds thousands of threads (called processes) without any trouble.
        Here's "Hello, World!" being printed by a thousand processes
        concurrently.

        <pre><code class="language-rust">import gleam/otp/process
import gleam/io
import gleam/int
import gleam/list
import gleam/string

pub fn main() {
  list.range(0, 1000)
  |&gt; list.each(start_process)
}

fn start_process(i) {
  process.start(fn() {
    "Hello world from process number "
    |&gt; string.append(int.to_string(i))
    |&gt; io.println
  })
}
</code></pre>

        In addition to this low-level process abstraction Gleam has helpful
        libraries full of building blocks for writing type safe and fault
        tolerant multi-core programs as quickly as possible.
      </details>

      <link
        rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css"
      />
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
      <script>
        hljs.initHighlightingOnLoad();
      </script>
    </section>

    <footer class="page-footer">
      Â© 2016 â€“ present Louis Pilfold
    </footer>
  </body>
</html>
