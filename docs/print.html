<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Gleam Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Hello, Gleam!</a></li><li><a href="getting-started/installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><a href="tour/index.html"><strong aria-hidden="true">3.</strong> Language tour</a></li><li><ol class="section"><li><a href="tour/string.html"><strong aria-hidden="true">3.1.</strong> String</a></li><li><a href="tour/bool.html"><strong aria-hidden="true">3.2.</strong> Bool</a></li><li><a href="tour/int-and-float.html"><strong aria-hidden="true">3.3.</strong> Int &amp; Float</a></li><li><a href="tour/let.html"><strong aria-hidden="true">3.4.</strong> Let bindings</a></li><li><a href="tour/tuple.html"><strong aria-hidden="true">3.5.</strong> Tuple</a></li><li><a href="tour/list.html"><strong aria-hidden="true">3.6.</strong> List</a></li><li><a href="tour/case.html"><strong aria-hidden="true">3.7.</strong> Case</a></li><li><a href="tour/function.html"><strong aria-hidden="true">3.8.</strong> Function</a></li><li><a href="tour/record.html"><strong aria-hidden="true">3.9.</strong> Record</a></li><li><a href="tour/enum.html"><strong aria-hidden="true">3.10.</strong> Enum</a></li><li><a href="tour/external-function.html"><strong aria-hidden="true">3.11.</strong> External function</a></li><li><a href="tour/external-type.html"><strong aria-hidden="true">3.12.</strong> External type</a></li><li><a href="tour/module.html"><strong aria-hidden="true">3.13.</strong> Module</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Gleam Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#gleam" id="gleam"><h1>Gleam</h1></a>
<p>Gleam is a statically typed functional programming language for building
scalable concurrent systems.</p>
<p>It compiles to <a href="http://www.erlang.org/">Erlang</a> and has straightforward
interop with other BEAM languages such as Erlang, Elixir and LFE.</p>
<p>It looks like this:</p>
<pre><code class="language-rust noplaypen">pub enum Tree =
  | Leaf(Int)
  | Node(Tree, Tree)

pub fn any(tree, predicate) {
  case tree {
  | Leaf(i) -&gt; predicate(i)
  | Node(left, right) -&gt; any(left, predicate) || any(right, predicate)
  }
}

pub fn has_even_leaf(tree) {
  any(tree, fn(i) {
    i % 2 == 0
  })
}
</code></pre>
<p>The source code can be found at
<a href="https://github.com/lpil/gleam">https://github.com/lpil/gleam</a>.</p>
<p>For Gleam chat we have the IRC channel <code>#gleam-lang</code> on Freenode.</p>
<a class="header" href="#principles" id="principles"><h2>Principles</h2></a>
<a class="header" href="#be-safe" id="be-safe"><h3>Be safe</h3></a>
<p>An expressive type system inspired by the ML family of languages helps us find
and prevent bugs at compile time, long before it reaches your users.</p>
<p>For the problems the type system can't solve (such as your server being hit by
a bolt of lightning) the Erlang/OTP runtime provides well tested mechanisms
for gracefully handling failure.</p>
<a class="header" href="#be-friendly" id="be-friendly"><h3>Be friendly</h3></a>
<p>Hunting down bugs can be stressful so feedback from the compiler should be
as clear and helpful as possible. We want to spend more time working on our
application and less time looking for typos or deciphering cryptic error
messages.</p>
<p>As a community we want to be friendly too. People of all backgrounds, genders,
and experience levels are welcome and must receive equal respect.</p>
<a class="header" href="#be-performant" id="be-performant"><h3>Be performant</h3></a>
<p>The Erlang/OTP runtime is known for its speed and ability to scale, enabling
organisations such as WhatsApp and Ericsson to reliably handle massive amounts
of traffic at low latency. Gleam should take full advantage of this runtime
and be as fast as other BEAM languages such as Erlang and Elixir.</p>
<a class="header" href="#be-a-good-citizen" id="be-a-good-citizen"><h3>Be a good citizen</h3></a>
<p>Gleam makes it easy to use code written in other BEAM languages such as
Erlang, Elixir and LFE, so there's a rich ecosystem of tools and library for
Gleam users to make use of.</p>
<p>Users of other BEAM languages should in return be able to take advantage of
Gleam, either by transparently making use of libraries written in Gleam, or by
adding Gleam modules to their existing project with minimal fuss.</p>
<a class="header" href="#warning-pre-release-software" id="warning-pre-release-software"><h1>Warning! Pre-release software</h1></a>
<p>The Gleam compiler is incomplete alpha software and is not yet intended for
general use. Many language features are not yet supported by the compiler and
compiler bugs are numerous, so running Gleam code will not be as pleasant an
experience as desired.</p>
<p>If you wish to continue anyway please follow the instructions below and record
any bugs or feedback on the <a href="https://github.com/lpil/gleam/issues">Gleam issue tracker</a>.</p>
<p>Good luck, have fun!</p>
<p><br></p>
<a class="header" href="#installation" id="installation"><h1>Installation</h1></a>
<p>A Gleam installation is made up of two parts: The Gleam compiler, and the
Erlang runtime.</p>
<a class="header" href="#installing-the-compiler" id="installing-the-compiler"><h2>Installing the compiler</h2></a>
<p>The compiler is written in the Rust programming language and must be build
from source. <a href="https://www.rust-lang.org/tools/install">Install the Rust compiler</a>
before proceeding.</p>
<pre><code class="language-sh"># Download the Gleam source code git repository
cd /tmp
git clone https://github.com/lpil/gleam.git
cd gleam

# Build the Gleam compiler. This will take some time!
make install

# Verify the compiler is installed
# Prints &quot;gleam $VERSION&quot;
gleam --version
</code></pre>
<a class="header" href="#installing-the-erlang-runtime" id="installing-the-erlang-runtime"><h2>Installing the Erlang runtime</h2></a>
<p>Gleam compiles to Erlang code, so Erlang needs to be installed to run Gleam
code.</p>
<p>Precompiled builds for many popular operating systems can be downloaded from
the <a href="https://www.erlang-solutions.com/resources/download.html">Erlang solutions website</a>,</p>
<p>Guides for installing Erlang on specific operating systems can be found below,
as well as information on installing multiple versions of Erlang at once using
version manager tools.</p>
<p>Once Erlang has been installed you can check it is working by typing <code>erl -version</code> in your computer's terminal. You will see version information like
this if all is well:</p>
<pre><code>$ erl -version
Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 10.1
</code></pre>
<a class="header" href="#linux" id="linux"><h3>Linux</h3></a>
<a class="header" href="#debian-linux" id="debian-linux"><h4>Debian Linux</h4></a>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<a class="header" href="#ubuntu-linux" id="ubuntu-linux"><h4>Ubuntu Linux</h4></a>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<a class="header" href="#mac-os-x" id="mac-os-x"><h3>Mac OS X</h3></a>
<a class="header" href="#using-homebrew" id="using-homebrew"><h4>Using Homebrew</h4></a>
<p>With <a href="https://brew.sh">Homebrew</a> installed run the following:</p>
<pre><code class="language-sh">brew update
brew install erlang
</code></pre>
<a class="header" href="#windows" id="windows"><h3>Windows</h3></a>
<a class="header" href="#using-chocolatey" id="using-chocolatey"><h4>Using Chocolatey</h4></a>
<p>With <a href="https://chocolatey.org/">Chocolatey</a> installed on your computer run the
following:</p>
<pre><code>choco install erlang
</code></pre>
<a class="header" href="#using-version-managers" id="using-version-managers"><h3>Using version managers</h3></a>
<a class="header" href="#asdf" id="asdf"><h4>asdf</h4></a>
<p>The asdf version manager has a plugin for installing Erlang. Installation and
usage instructions can be found here:</p>
<ul>
<li><a href="https://github.com/asdf-vm/asdf">https://github.com/asdf-vm/asdf</a></li>
<li><a href="https://github.com/asdf-vm/asdf-erlang">https://github.com/asdf-vm/asdf-erlang</a></li>
</ul>
<a class="header" href="#language-tour" id="language-tour"><h1>Language Tour</h1></a>
<p>In this chapter we explore the fundamentals of the Gleam language, namely its
syntax, core data structures, flow control features, and static type system.</p>
<p>After completion the reader should know enough to start reading and writing
Gleam code, assuming they have some prior programming experience.</p>
<p>In some section we touch on the runtime representation of various features.
This is useful for programmers with Erlang or Elixir experience who wish to
use Gleam alongside these languages. If you are using Gleam alone this
information can be safely ignored.</p>
<a class="header" href="#string" id="string"><h1>String</h1></a>
<p>Gleam's has UTF-8 binary strings, written as text surrounded by double quotes.</p>
<pre><code class="language-rust noplaypen">&quot;Hello, Gleam!&quot;
</code></pre>
<p>Strings can span multiple lines.</p>
<pre><code class="language-rust noplaypen">&quot;Hello
Gleam!&quot;
</code></pre>
<p>Special characters such as <code>&quot;</code> need to be escaped with a <code>\</code> character.</p>
<pre><code class="language-rust noplaypen">&quot;Here is a double quote -&gt; \&quot; &lt;-&quot;
</code></pre>
<a class="header" href="#bool" id="bool"><h1>Bool</h1></a>
<p>A Bool can be either <code>True</code> or <code>False</code>.</p>
<p>Gleam defines a handful of operators that work with Bools.</p>
<pre><code class="language-rust noplaypen">False &amp;&amp; False // =&gt; False
False &amp;&amp; True  // =&gt; False
True &amp;&amp; False  // =&gt; False
True &amp;&amp; True   // =&gt; True

False || False // =&gt; False
False || True  // =&gt; True
True || False  // =&gt; True
True || True   // =&gt; True
</code></pre>
<p><code>&amp;&amp;</code> and <code>||</code> are <em>short circuiting</em>, meaning they don't evaluate the right
hand side if they don't have to.</p>
<p><code>&amp;&amp;</code> evaluates the right hand side if the left hand side is <code>True</code>.</p>
<p><code>||</code> evaluates the right hand side if the left hand side is <code>False</code>.</p>
<a class="header" href="#erlang-interop" id="erlang-interop"><h2>Erlang interop</h2></a>
<p>While written in the code using a capital letter, they are represented at
runtime with the atoms <code>true</code> and <code>false</code>, making them compatible with Elixir
and Erlang's booleans.</p>
<p>This is important if you want to use Gleam and Elixir or Erlang together in
one project.</p>
<pre><code class="language-rust noplaypen">// Gleam
True
False
</code></pre>
<pre><code class="language-erlang">% Erlang
true.
false.
</code></pre>
<a class="header" href="#int-and-float" id="int-and-float"><h1>Int and Float</h1></a>
<p>Gleam's main number types are Int and Float.</p>
<a class="header" href="#ints" id="ints"><h2>Ints</h2></a>
<p>Ints are &quot;whole&quot; numbers.</p>
<pre><code class="language-rust noplaypen">1
2
-3
4001
</code></pre>
<p>Gleam has several operators that work with Ints, all of which return Ints.</p>
<pre><code class="language-rust noplaypen">1 + 1 // =&gt; 2
5 - 1 // =&gt; 4
5 / 2 // =&gt; 2
3 * 3 // =&gt; 9
5 % 2 // =&gt; 1
</code></pre>
<a class="header" href="#floats" id="floats"><h2>Floats</h2></a>
<p>Floats are numbers that have a decimal point.</p>
<pre><code class="language-rust noplaypen">1.5
2.0
-0.1
</code></pre>
<p>Floats also have their own set of operators.</p>
<pre><code class="language-rust noplaypen">1.0 +. 1.4 // =&gt; 2.4
5.0 -. 1.5 // =&gt; 3.5
5.0 /. 2.0 // =&gt; 2.5
3.0 *. 3.1 // =&gt; 9.3
</code></pre>
<a class="header" href="#let-bindings" id="let-bindings"><h1>Let bindings</h1></a>
<p>A value can be given a name using <code>let</code>. Names can be reused by later let
bindings, but the values contained are <em>immutable</em>, meaning the values
themselves cannot be changed.</p>
<pre><code class="language-rust noplaypen">let x = 1
let y = x
let x = 2

x  // =&gt; 2
y  // =&gt; 1
</code></pre>
<a class="header" href="#tuples" id="tuples"><h1>Tuples</h1></a>
<p>Tuples are an ordered collection of elements of a fixed size. Each element can
be of a different type.</p>
<pre><code class="language-rust noplaypen">{&quot;Cat&quot;, True}  // Type {String, Bool}
{1, 2.0, &quot;3&quot;}  // Type {Int, Float, String}
</code></pre>
<p>Contained values can be extracted from tuples using a let binding.</p>
<pre><code class="language-rust noplaypen">let values = {1, 2.0}
let {x, y} = values

x  // =&gt; 1
y  // =&gt; 2.0
</code></pre>
<a class="header" href="#list" id="list"><h1>List</h1></a>
<p>Lists are ordered collections of values. They're one of the most common data
structures in Gleam.</p>
<p>Lists are <em>homogeneous</em>, meaning all the elements of a List must be of the
same type. Attempting to construct a list of multiple types of element will
result in the compiler presenting a type error.</p>
<pre><code class="language-rust noplaypen">[1, 2, 3, 4]  // List(Int)
[1.22, 2.30]  // List(Float)
[1.22, 3, 4]  // Type error!
</code></pre>
<p>Prepending to a list is very fast, and is the preferred way to add new values.</p>
<pre><code class="language-rust noplaypen">[1 | [2, 3]]  // =&gt; [1, 2, 3]
</code></pre>
<p>Note that as all data structures in Gleam are immutable so prepending to a
list does not change the original list, instead it efficiently creates a new
list with the new additional element.</p>
<pre><code class="language-rust noplaypen">let x = [2, 3]
let y = [1 | x]


x  // =&gt; [2, 3]
y  // =&gt; [1, 2, 3]
</code></pre>
<a class="header" href="#case" id="case"><h1>Case</h1></a>
<p>The <code>case</code> expression is the most common kind of flow control in Gleam code. It
allows us to say &quot;if the data has this shape then do that&quot;, which we call
<em>pattern matching</em>.</p>
<p>Here we match on an <code>Int</code> and return a specific string for the values 0, 1,
and 2. The final pattern <code>n</code> matches any other value that did not match any of
the previous patterns.</p>
<pre><code class="language-rust noplaypen">case some_number {
| 0 -&gt; &quot;Zero&quot;
| 1 -&gt; &quot;One&quot;
| 2 -&gt; &quot;Two&quot;
| n -&gt; &quot;Some other number&quot; // This matches anything
}
</code></pre>
<p>Pattern matching on a <code>Bool</code> value is the Gleam alternative to the <code>if else</code>
statement found in other languages.</p>
<pre><code class="language-rust noplaypen">case some_bool {
| True -&gt; &quot;It's true!&quot;
| False -&gt; &quot;It's not true.&quot;
}
</code></pre>
<p>Gleam's <code>case</code> is an expression, meaning it returns a value and can be used
anywhere we would use a value. For example, we can name the value of a case
expression with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">let description =
  case True {
  | True -&gt; &quot;It's true!&quot;
  | False -&gt; &quot;It's not true.&quot;
  }

description  // =&gt; &quot;It's true!&quot;
</code></pre>
<a class="header" href="#destructuring" id="destructuring"><h2>Destructuring</h2></a>
<p>Like <code>let</code> bindings a <code>case</code> expression can be used to destructure values that
contain other values, such as tuples and lists.</p>
<pre><code class="language-rust noplaypen">case xs {
| [] -&gt; &quot;This list is empty&quot;
| [a] -&gt; &quot;This list has 1 element&quot;
| [a, b] -&gt; &quot;This list has 2 element&quot;
| other -&gt; &quot;This list has more than 2 elements&quot;
}
</code></pre>
<p>It's not just the top level data structure that can be pattern matches,
contained values can also be matched. This gives <code>case</code> the ability to
concisely express flow control that might be verbose without pattern matching.</p>
<pre><code class="language-rust noplaypen">case xs {
| [[]] -&gt; &quot;The only element is an empty list&quot;
| [[] | _] -&gt; &quot;The 1st element is an empty list&quot;
| [[4] | _] -&gt; &quot;The 1st element is a list of the number 4&quot;
| other -&gt; &quot;Something else&quot;
}
</code></pre>
<pre><code class="language-rust noplaypen">case xs {
| {1, _} -&gt; &quot;The 1st element is 1&quot;
| {_, 1} -&gt; &quot;The 2nd element is 1&quot;
| other -&gt; &quot;Something else&quot;
}
</code></pre>
<a class="header" href="#function" id="function"><h1>Function</h1></a>
<a class="header" href="#named-functions" id="named-functions"><h2>Named functions</h2></a>
<p>Named functions in Gleam are defined using the <code>fn</code> keyword and are made
public with the <code>pub</code> keyword.</p>
<pre><code class="language-rust noplaypen">// This function is private and can only be called from the same module
fn add(x, y) {
  x + y
}

// This function is public and can be called from other modules
pub fn multiply(x, y) {
  x * y
}
</code></pre>
<p>Functions in Gleam are first class values and so can be assigned to variables,
passed to functions, or anything else you might do with any other data type.</p>
<pre><code class="language-rust noplaypen">// This function takes a function as an argument
fn twice(f, x) {
  f(f(x))
}

fn add_one(x) {
  x + 1
}

fn add_two(x) {
  twice(add_one, x)
}
</code></pre>
<a class="header" href="#anonymous-functions" id="anonymous-functions"><h2>Anonymous functions</h2></a>
<p>Anonymous functions can be defined with a similar syntax.</p>
<pre><code class="language-rust noplaypen">pub fn run() {
  let add = fn(x, y) { x + y }

  add(1, 2)
}
</code></pre>
<a class="header" href="#function-capturing" id="function-capturing"><h2>Function capturing</h2></a>
<p>There is a shorthand syntax for creating anonymous functions that take one
argument and call another function. The <code>_</code> is used to indicate where the
argument should be passed.</p>
<pre><code class="language-rust noplaypen">fn add(x, y) {
  x + y
}

pub fn run() {
  let add_one = add(1, _)

  add_one(2)
}
</code></pre>
<p>The function capture syntax is often used with the pipe operator to create
a series of transformations on some data.</p>
<pre><code class="language-rust noplaypen">fn add(x, y) {
  x + y
}

pub fn run() {
  // This is the same as add(add(add(1, 3), 6), 9)
  1
  |&gt; add(_, 3)
  |&gt; add(_, 6)
  |&gt; add(_, 9)
}
</code></pre>
<a class="header" href="#records" id="records"><h1>Records</h1></a>
<p>Gleam's records are a collection of names and values where each value can be
of any type.</p>
<pre><code class="language-rust noplaypen">{
  name = &quot;Rex&quot;,
  size = 40,
}
</code></pre>
<a class="header" href="#accessing-field-values" id="accessing-field-values"><h2>Accessing field values</h2></a>
<p>Record values can be accessed using the <code>record.field_name</code> syntax.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }
let name = pup.name

name  // =&gt; &quot;Rex&quot;
</code></pre>
<a class="header" href="#inserting-field-values" id="inserting-field-values"><h2>Inserting field values</h2></a>
<p>A new record with updated or additional fields can be created using the
<code>{ record | field_name = value }</code> update syntax.</p>
<p>The updated record fields do not have to have the same types as the original
fields.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }
let dog = { pup | size = 70, playful = True }

pup  // { name = &quot;Rex&quot;, size = 40 }
dog  // { name = &quot;Rex&quot;, size = 70, playful = True }
</code></pre>
<a class="header" href="#types" id="types"><h2>Types</h2></a>
<p>The type of a record depends upon the names and types of its fields.</p>
<pre><code class="language-rust noplaypen">{ name = &quot;Rex&quot; }             // Type { name = String }
{ name = &quot;Rex&quot;, size = 40 }  // Type { name = String, size = Int }
</code></pre>
<p>The Gleam compiler keeps tracks of what fields and values each record has and
will present a compile time error if you try to use a record field that does
not exist or has the incorrect type.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }

pup.address   // Compile time error! Unknown field
pup.name + 1  // Compile time error! Wrong type
</code></pre>
<a class="header" href="#parameterised-record-fields" id="parameterised-record-fields"><h3>Parameterised record fields</h3></a>
<p>Gleam's type system aims to be as permissive when it comes to records passed
to functions. Take this function for example.</p>
<pre><code class="language-rust noplaypen">fn get_following_year(record) {
  record.year + 1
}
</code></pre>
<p>The type of this function is <code>fn({ a | year = Int }) -&gt; Int</code>.</p>
<p>The <code>a |</code> in <code>{ a | year = Int}</code> means &quot;any other fields&quot;, so this function
can be called with any record so long as the record has a <code>year</code> field that
has an <code>Int</code> value.</p>
<pre><code class="language-rust noplaypen">let date = { day = 5, month: 1, year = 2019 }
let book = { title = &quot;Sabriel&quot;, year = 1995 }
let soup = { kind = &quot;Tomato&quot;, spicy = False }
let wine = { kind = &quot;Fancy!&quot;, year = &quot;Good&quot; }

get_following_year(date)  // =&gt; 2020
get_following_year(book)  // =&gt; 1996
get_following_year(soup)  // Compile time error! No year field
get_following_year(wine)  // Compile time error! Wrong field type
</code></pre>
<a class="header" href="#erlang-interop-1" id="erlang-interop-1"><h2>Erlang interop</h2></a>
<p>At runtime records are maps with atom keys. They are not the same as Erlang
records, which are tuples. They are similar to Elixir's structs, but do not
need to be declared prior to being used.</p>
<a class="header" href="#enums" id="enums"><h1>Enums</h1></a>
<p>Enums in Gleam are a way of modeling data that can be one of a few different
variants. They must be declared before use, and the names of variants must be
unique for the given module.</p>
<p>We've seen an enum already in this chapter- <code>Bool</code>.</p>
<p>Bool is defined like this:</p>
<pre><code class="language-rust noplaypen">// A Bool is a value that is either `True` or `False`
enum Bool =
  | True
  | False
</code></pre>
<p>Enum variants can also contain other values, and these values can be extracted
using a let binding.</p>
<pre><code class="language-rust noplaypen">enum User =
  | LoggedIn(String)  // A logged in user with a name
  | Guest             // A guest user with no details
</code></pre>
<pre><code class="language-rust noplaypen">let sara = LoggedIn(&quot;Sara&quot;)
let rick = LoggedIn(&quot;Rick&quot;)
let visitor = Guest
</code></pre>
<a class="header" href="#destructuring-1" id="destructuring-1"><h2>Destructuring</h2></a>
<p>When given an enum we can pattern match on it to determine which variant it is
and to assign names to any contained values.</p>
<pre><code class="language-rust noplaypen">fn get_name(user) {
  case user {
  | LoggedIn(name) -&gt; name
  | Guest -&gt; &quot;Guest user&quot;
  }
}
</code></pre>
<p>Enums can also be destructured with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">enum Score =
  | Points(Int)
</code></pre>
<pre><code class="language-rust noplaypen">let score = Points(50)
let Points(p) = score

p // =&gt; 50
</code></pre>
<a class="header" href="#erlang-interop-2" id="erlang-interop-2"><h2>Erlang interop</h2></a>
<p>At runtime enum variants with no contained values become atoms. The atoms are
written in <code>snake_case</code> rather than <code>CamelCase</code> so <code>LoggedIn</code> becomes
<code>logged_in</code>.</p>
<p>Enum variants with contained values become tuples with a tag atom.</p>
<pre><code class="language-rust noplaypen">// Gleam
Guest
LoggedIn(&quot;Kim&quot;)
</code></pre>
<pre><code># Elixir
:guest
{:logged_in, &quot;Kim&quot;}
</code></pre>
<pre><code>% Erlang
guest.
{logged_in, &lt;&lt;&quot;Kim&quot;&gt;&gt;}.
</code></pre>
<a class="header" href="#external-function" id="external-function"><h1>External function</h1></a>
<p>Gleam is just one of many languages on the Erlang virtual machine and at times
we may want to use functions from these other languages in our Gleam programs.
To enable this Gleam allows the importing of <em>external functions</em>, which may
be written in any BEAM language.</p>
<p>External functions are typically written in a different language with a
different type system, so the compiler is unable to determine the type of the
function and instead the programmer must inform the compiler the type.</p>
<p>Gleam trusts that the type given is correct so an inaccurate type annotation
can result in unexpected behaviour and crashes at runtime. Be careful!</p>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>The Erlang <code>rand</code> module has a function named <code>uniform</code> that takes no
arguments and returns a <code>Float</code>.</p>
<p>The Elixir module <code>IO</code> has a function named <code>inspect</code> that takes any value,
prints it, and returns the same value.</p>
<p>If we want to import these functions and use them in our program we would do
so like this:</p>
<pre><code class="language-rust noplaypen">pub external fn random_float() -&gt; Float = &quot;rand&quot; &quot;uniform&quot;

// Elixir modules start with `Elixir.`
pub external fn inspect(a) -&gt; a = &quot;Elixir.IO&quot; &quot;inspect&quot;
</code></pre>
<a class="header" href="#external-type" id="external-type"><h1>External type</h1></a>
<p>In addition to importing external functions we can also import external types.
Gleam knows nothing about the runtime representation of these types and so
they cannot be pattern matched on, but they can be used with external
functions that know how to work with them.</p>
<p>Here is an example of importing a <code>Queue</code> data type and some functions from
Erlang's <code>queue</code> module to work with the new <code>Queue</code> type.</p>
<pre><code class="language-rust noplaypen">pub external type Queue(a)

pub external fn new() -&gt; Queue(a) = &quot;queue&quot; &quot;new&quot;

pub external fn length(Queue(a)) -&gt; Int = &quot;queue&quot; &quot;len&quot;

pub external fn push(Queue(a), a) -&gt; Queue(a) = &quot;queue&quot; &quot;in&quot;
</code></pre>
<a class="header" href="#module" id="module"><h1>Module</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
